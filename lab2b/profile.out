Total: 544 samples
     509  93.6%  93.6%      544 100.0% thread_worker
       7   1.3%  94.9%        7   1.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       6   1.1%  96.0%        6   1.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:204
       6   1.1%  97.1%       17   3.1% SortedList_insert
       6   1.1%  98.2%       18   3.3% SortedList_lookup
       3   0.6%  98.7%        3   0.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       2   0.4%  99.1%        2   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       1   0.2%  99.3%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:161
       1   0.2%  99.4%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:165
       1   0.2%  99.6%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:211
       1   0.2%  99.8%        1   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1734
       1   0.2% 100.0%        1   0.2% _init
       0   0.0% 100.0%      544 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:118
       0   0.0% 100.0%      544 100.0% start_thread
ROUTINE ====================== thread_worker in /u/cs/ugrad/zhengton/cs111/lab2b/lab2_list.c
   509    544 Total samples (flat / cumulative)
     .      .  309:     
     .      .  310:     return true;
     .      .  311: }
     .      .  312: 
     .      .  313: void *thread_worker(void *arg)
---
     .      .  314: {
     .      .  315:     long thread_num = *((long*)arg);
     .      .  316:     long start_index = thread_num * iteration;
     .      .  317:     // insert elements with or without lock
     .      .  318:     for (long i = start_index; i < start_index + iteration; i++)
     .      .  319:     {
     .      .  320:         if (sync_type == 'm')
     .      .  321:         {
     .      .  322:             pthread_mutex_lock(&mutex);
     .      .  323:             SortedList_insert(listhead, &pool[i]);
     .      .  324:             pthread_mutex_unlock(&mutex);
     .      .  325:         }
     .      .  326:         else if (sync_type == 's')
     .      .  327:         {
   328    328  328:             while (__sync_lock_test_and_set(&lock, 1));
     .     17  329:             SortedList_insert(listhead, &pool[i]);
     .      .  330:             __sync_lock_release(&lock);
     .      .  331:         }
     .      .  332:         else if (sync_type != 'm' && sync_type != 's')
     .      .  333:             SortedList_insert(listhead, &pool[i]);
     .      .  334:     }
     .      .  335:     // get sorted list length with and without lock
     .      .  336:     long len = 0;
     .      .  337:     if (sync_type == 'm')
     .      .  338:     {
     .      .  339:         pthread_mutex_lock(&mutex);
     .      .  340:         len = SortedList_length(listhead);
     .      .  341:         if (len < 0)
     .      .  342:         {
     .      .  343:             fprintf(stderr, "the sorted list is corrupted\n");
     .      .  344:             exit(2);
     .      .  345:         }
     .      .  346:         pthread_mutex_unlock(&mutex);
     .      .  347:     }
     .      .  348:     else if (sync_type == 's')
     .      .  349:     {
     .      .  350:         while (__sync_lock_test_and_set(&lock, 1));
     .      .  351:         len = SortedList_length(listhead);
     .      .  352:         if (len < 0)
     .      .  353:         {
     .      .  354:             fprintf(stderr, "the sorted list is corrupted\n");
     .      .  355:             exit(2);
     .      .  356:         }
     .      .  357:         __sync_lock_release(&lock);
     .      .  358:     }
     .      .  359:     else if (sync_type != 'm' && sync_type != 's')
     .      .  360:     {
     .      .  361:         len = SortedList_length(listhead);
     .      .  362:         if (len < 0)
     .      .  363:         {
     .      .  364:             fprintf(stderr, "the sorted list is corrupted\n");
     .      .  365:             exit(2);
     .      .  366:         }
     .      .  367:     }
     .      .  368: 
     .      .  369:     // look up and delete sorted list elements with and without lock
     .      .  370:     SortedListElement_t *element;
     .      .  371:     for (long i = start_index; i < start_index + iteration; i++) {
     .      .  372:         if (sync_type == 'm')
     .      .  373:         {
     .      .  374:             pthread_mutex_lock(&mutex);
     .      .  375:             element = SortedList_lookup(listhead, pool[i].key);
     .      .  376:             if (element == NULL)
     .      .  377:             {
     .      .  378:                 fprintf(stderr, "element not found in this sorted list\n");
     .      .  379:                 exit(2);
     .      .  380:             }
     .      .  381:             if (SortedList_delete(element) == 1)
     .      .  382:             {
     .      .  383:                 fprintf(stderr, "prev/next of this element is corrupted\n");
     .      .  384:                 exit(2);
     .      .  385:             }
     .      .  386:             pthread_mutex_unlock(&mutex);
     .      .  387:         }
     .      .  388:         else if (sync_type == 's')
     .      .  389:         {
   181    181  390:             while (__sync_lock_test_and_set(&lock, 1));
     .     18  391:             element = SortedList_lookup(listhead, pool[i].key);
     .      .  392:             if (element == NULL)
     .      .  393:             {
     .      .  394:                 fprintf(stderr, "element not found in this sorted list\n");
     .      .  395:                 exit(2);
     .      .  396:             }
     .      .  397:             if (SortedList_delete(element) == 1)
     .      .  398:             {
     .      .  399:                 fprintf(stderr, "prev/next of this element is corrupted\n");
     .      .  400:                 exit(2);
     .      .  401:             }
     .      .  402:             __sync_lock_release(&lock);
     .      .  403:         }
     .      .  404:         else if (sync_type != 'm' && sync_type != 's')
     .      .  405:         {
     .      .  406:             element = SortedList_lookup(listhead, pool[i].key);
     .      .  407:             if (element == NULL)
     .      .  408:             {
     .      .  409:                 fprintf(stderr, "element not found in this sorted list\n");
     .      .  410:                 exit(2);
     .      .  411:             }
     .      .  412:             if (SortedList_delete(element) == 1)
     .      .  413:             {
     .      .  414:                 fprintf(stderr, "prev/next of this element is corrupted\n");
     .      .  415:                 exit(2);
     .      .  416:             }
     .      .  417:         }
     .      .  418:     }
     .      .  419:     
     .      .  420:     return arg;
     .      .  421: }
---
     .      .  422: 
     .      .  423: void segfault_handler (int sig)
     .      .  424: {
     .      .  425:     if (sig == SIGSEGV)
     .      .  426:     {
ROUTINE ====================== thread_worker in /u/cs/ugrad/zhengton/cs111/lab2b/lab2_list.c
   509    544 Total samples (flat / cumulative)
     .      .  309:     
     .      .  310:     return true;
     .      .  311: }
     .      .  312: 
     .      .  313: void *thread_worker(void *arg)
---
     .      .  314: {
     .      .  315:     long thread_num = *((long*)arg);
     .      .  316:     long start_index = thread_num * iteration;
     .      .  317:     // insert elements with or without lock
     .      .  318:     for (long i = start_index; i < start_index + iteration; i++)
     .      .  319:     {
     .      .  320:         if (sync_type == 'm')
     .      .  321:         {
     .      .  322:             pthread_mutex_lock(&mutex);
     .      .  323:             SortedList_insert(listhead, &pool[i]);
     .      .  324:             pthread_mutex_unlock(&mutex);
     .      .  325:         }
     .      .  326:         else if (sync_type == 's')
     .      .  327:         {
   328    328  328:             while (__sync_lock_test_and_set(&lock, 1));
     .     17  329:             SortedList_insert(listhead, &pool[i]);
     .      .  330:             __sync_lock_release(&lock);
     .      .  331:         }
     .      .  332:         else if (sync_type != 'm' && sync_type != 's')
     .      .  333:             SortedList_insert(listhead, &pool[i]);
     .      .  334:     }
     .      .  335:     // get sorted list length with and without lock
     .      .  336:     long len = 0;
     .      .  337:     if (sync_type == 'm')
     .      .  338:     {
     .      .  339:         pthread_mutex_lock(&mutex);
     .      .  340:         len = SortedList_length(listhead);
     .      .  341:         if (len < 0)
     .      .  342:         {
     .      .  343:             fprintf(stderr, "the sorted list is corrupted\n");
     .      .  344:             exit(2);
     .      .  345:         }
     .      .  346:         pthread_mutex_unlock(&mutex);
     .      .  347:     }
     .      .  348:     else if (sync_type == 's')
     .      .  349:     {
     .      .  350:         while (__sync_lock_test_and_set(&lock, 1));
     .      .  351:         len = SortedList_length(listhead);
     .      .  352:         if (len < 0)
     .      .  353:         {
     .      .  354:             fprintf(stderr, "the sorted list is corrupted\n");
     .      .  355:             exit(2);
     .      .  356:         }
     .      .  357:         __sync_lock_release(&lock);
     .      .  358:     }
     .      .  359:     else if (sync_type != 'm' && sync_type != 's')
     .      .  360:     {
     .      .  361:         len = SortedList_length(listhead);
     .      .  362:         if (len < 0)
     .      .  363:         {
     .      .  364:             fprintf(stderr, "the sorted list is corrupted\n");
     .      .  365:             exit(2);
     .      .  366:         }
     .      .  367:     }
     .      .  368: 
     .      .  369:     // look up and delete sorted list elements with and without lock
     .      .  370:     SortedListElement_t *element;
     .      .  371:     for (long i = start_index; i < start_index + iteration; i++) {
     .      .  372:         if (sync_type == 'm')
     .      .  373:         {
     .      .  374:             pthread_mutex_lock(&mutex);
     .      .  375:             element = SortedList_lookup(listhead, pool[i].key);
     .      .  376:             if (element == NULL)
     .      .  377:             {
     .      .  378:                 fprintf(stderr, "element not found in this sorted list\n");
     .      .  379:                 exit(2);
     .      .  380:             }
     .      .  381:             if (SortedList_delete(element) == 1)
     .      .  382:             {
     .      .  383:                 fprintf(stderr, "prev/next of this element is corrupted\n");
     .      .  384:                 exit(2);
     .      .  385:             }
     .      .  386:             pthread_mutex_unlock(&mutex);
     .      .  387:         }
     .      .  388:         else if (sync_type == 's')
     .      .  389:         {
   181    181  390:             while (__sync_lock_test_and_set(&lock, 1));
     .     18  391:             element = SortedList_lookup(listhead, pool[i].key);
     .      .  392:             if (element == NULL)
     .      .  393:             {
     .      .  394:                 fprintf(stderr, "element not found in this sorted list\n");
     .      .  395:                 exit(2);
     .      .  396:             }
     .      .  397:             if (SortedList_delete(element) == 1)
     .      .  398:             {
     .      .  399:                 fprintf(stderr, "prev/next of this element is corrupted\n");
     .      .  400:                 exit(2);
     .      .  401:             }
     .      .  402:             __sync_lock_release(&lock);
     .      .  403:         }
     .      .  404:         else if (sync_type != 'm' && sync_type != 's')
     .      .  405:         {
     .      .  406:             element = SortedList_lookup(listhead, pool[i].key);
     .      .  407:             if (element == NULL)
     .      .  408:             {
     .      .  409:                 fprintf(stderr, "element not found in this sorted list\n");
     .      .  410:                 exit(2);
     .      .  411:             }
     .      .  412:             if (SortedList_delete(element) == 1)
     .      .  413:             {
     .      .  414:                 fprintf(stderr, "prev/next of this element is corrupted\n");
     .      .  415:                 exit(2);
     .      .  416:             }
     .      .  417:         }
     .      .  418:     }
     .      .  419:     
     .      .  420:     return arg;
     .      .  421: }
---
     .      .  422: 
     .      .  423: void segfault_handler (int sig)
     .      .  424: {
     .      .  425:     if (sig == SIGSEGV)
     .      .  426:     {
